# IkasanStudio

![Build](https://github.com/davidhilton68/IkasanStudio2/workflows/Build/badge.svg)
[![Version](https://img.shields.io/jetbrains/plugin/v/PLUGIN_ID.svg)](https://plugins.jetbrains.com/plugin/PLUGIN_ID)
[![Downloads](https://img.shields.io/jetbrains/plugin/d/PLUGIN_ID.svg)](https://plugins.jetbrains.com/plugin/PLUGIN_ID)

[template]: https://github.com/JetBrains/intellij-platform-plugin-template
[docs:plugin-description]: https://plugins.jetbrains.com/docs/intellij/plugin-user-experience.html#plugin-description-and-presentation
## High level design / motivations
* Scaling
  * Reduced learning time for new resources.
  * Reduced complexity for new resources.
  * Reduced time to production since most of the code is already written.
  * Simple modules can be generated directly by the business owner.
* Quality - 
  * The majority of module is code via configuration, with the underlying code / generated based on best practice implementations from the Ikasan core team.
  * The graphical representation of the module quickly exposes flaws in the business process path.
  * Opportunities for localised developer testing and debugging.
  * Configuration is subjected to validation checks reducing semantic errors.
  * Core (generated) code is subjected to enhanced automated testing.
  * Developers are focused on the exception processing, with more time to extend testing for the bespoke data transformations.
  * Core developers are focused on enhancements to the core code
  * Opportunities for daily improvement via CI against the core libraries.
  * Localised payload transformation analysis assists with production issue replication and resolution.
* Migration
  * The json model creates a layer of abstraction between the business 'application' and the underlying version of Ikasan, once standard meta-packs have been written, upgrading or downgrading versions of Ikasan can be a simple as a drop-down chooser.
* Transparency
  * The business and IT can collaborate quickly on the model generation.
  * The model diagram forms part of the delivery, by definition will always be upto date.
* Cost of ownership
  * Corporate coding standards and implementation standards enforced by the auto-generated code.
  * Consistency in implementation reduces support costs.
  * Reduction in project written code results in reduction of development time and all related QA activities
  * Upgrades between versions of Ikasan greatly simplified via json (not Java) as the source code model, reducing legacy friction and therefore legacy support costs.
  * Improvements and bug fixes to core Ikasan features can be applied with reduced / no alteration to the module configuration / bespoke code.
  * Localised developer testing and debugging reduces the reliance on expensive centralised server resource
* Flexibility 
  * Custom components or implementations can be generated by development teams, with either minor extensions or complete bespoke library of components.
  * Custom components have a lifecycle route back to the core libraries

## Application Split

Offering is split into 3 artefects with independant lifecycles

### Core (org.ikasan.studio.core)
* Contains the model.json (de)serialisation
* Framework for code generation (ftl supplied by meta pack), 
* Framework for unit test support for meta pack, abstract support for meta pack

### Metapack (resources/studio/metapack) - depdends on Core
* One per supported Ikasan version
* Reduces the number of updates to the core (UI) plugin, the metapack can be added to (almost) any version of the plugin
* Distribution / exposed via web / repo / something
* Component Library - Encapsulates the Components properties, meta information, helptext, icons and ftl for a version of Ikasan, or an 'approach to auto-generation implementation', or user created components / code practice. 
* Provides extensive unit testing to self certify
* End user encouraged to create their own, only official metapacks are 'supported'

### UI (org.ikasan.studio.ui) - Depends on Core and Metapackbs
* Business driver is cost saving resulting from standard coding of components, reduced build times, reduced migration between versions of Ikasan, reduced complexity in legacy code base
* The UI should be easy to use, intuitive, dumb down usage for junior / mid-tier devs
* Abstracted to be driven from the content of a meta pack
* Support for multiple simultaneous metapacks
* Resilient and defensive, the UI needs to accommodate developer errors (misconfigured flows or metapacks) without resulting in serious errors in the IDE (Intellij are very keen to expose even slightly wonky plugins). Where possible the IDE should recover misconfiguration and inform the user via popup / message baloons.
## Epics / major stories

Core
* Extract the 'core' part into standard maven1 project, build into jar and expose in repo accessible by project (CAUTION - resource restrictions in official Ikasan Github)
* Create builder / Maven integration for non-UI code regeneration, integrate into maven
* Expand out model.json to accommodate 'code hooks' and any non-standard attributes e.g. meta-pack version (organic, maybe driven by needs of UI)
* Parameterize meta pack version in build
* Explore DB driven configuration

Meta pack(s)
* Migrate remaining part done 2023 components
* Remove old lookup mechanism
* Verify Exception resolver
* Add 'advanced config' tag for use in UI
* Add in all Ikasan standard components to meta pack with associated free marker templates
* Split out metapack with its unit tests into seperate module with dependent on code
* Add in aggregate components with associated free marker templates
* Add metapacks for Ikasan V4.x

UI
* Code to support user implemented and user supplied classes - integration into model.json, including 'shared' poms and properties - maybe explore multiple project roots.
* Validate current methods to run from UI
* Component deletion handling
* Debug mode, Message flow debug using wiretap
* Robustness tests
* Integrate 'advanced config' concept to reduce noise in UI
* Support archetype to build the project, maybe partially implemented projects.
* Sort out icons with correct scalling and transparency to support standard Intellj themes
* Update UI look and feel for all modes of Intellij themes
* Eclipse, Vaaden, Javascript based IDE
* Data exchange / XML mmapping of payload
* Parameterise meta pack version in model startup
* Explore DB driven configuration

CI
* Determine how / what output from the build process are integrated into standard M processing.
* Solution for artefact storage issue

Other
* Videos
* Help wiki
* Demos
* Jira ?
* Public Forum for self-help (stack overflow sub-site)
## Running Ikasan Studio
### Running the project locally
The simplest way to startup Ikasan Studio is to checkout this project locally and execute the 'Run Plugin' Gradle run configuration. This is only recommended for developers working on the plugin.
### Installing the plugin
Once the first release candidate has been approved by the core Ikasan team, the plugin for Ikasan Studio will be available in the standard plugin marketplace. In the meantime however, it is possible to generater the plugin 'zip' distribution and load it manually into Intellij.

To generate the 'zip' distribution, invoke the 'intellij/buildPlugin' Gradle target to create IkasanStudio-1.0.0.zip file.

Once created, this zip distribution can be loaded into any intellij via the Settings/Plugins /Cog Wheel/Install plugin from Disk.

<img src="docs/images/20240415-Intellij-AddPlugin.png" alt="Install Plugin from Disk" width="600">

### Installing the maven archetype
Once the first release candidate has been approved by the core Ikasan team, the archetype can be deployed to standard external maven repositories, in the meantime, the archetype needs to be installed manually.

The archetype zip can be generated by opening a window in IkasaStudio/studio-project-archetyp and issuing the maven command

`mvn clean package`

This will create a jar file in the target folder with the name studio-project-archetype-1.0-SNAPSHOT.jar

This first needs to be uploaded into your local Maven archetype library (~/.m2/repository/archetype-catalog.xml) using the following maven command:

**Unix**

`mvn install:install-file -Dfile=./target/studio-project-archetype-1.0-SNAPSHOT.jar -DgroupId=org.ikasan.studio -DartifactId=studio-project  -Dversion=1.0-SNAPSHOT -Dpackaging=jar`

**Windows (which needs each -D option surrounded by douple quotes)**

`mvn install:install-file "-Dfile=.\target\studio-project-archetype-1.0-SNAPSHOT.jar" "-DgroupId=org.ikasan.studio" "-DartifactId=studio-project"  "-Dversion=1.0-SNAPSHOT" "-Dpackaging=jar"`
(you may need to also perform mvn.cmd archetype:crawl if you can't find ~/.m2/repository/archetype-catalog.xml)

In theory, this can now be loaded into Intellij, but there seems to be inconsistent support for **uploaded catalogs on Windows, I expect when we formally deploy the archetype this won't be an issue.**
For now, you shiuld find that the maven from the command line will work:

`mvn archetype:generate -DarchetypeGroupId=org.ikasan.studio -DarchetypeArtifactId=studio-project -DarchetypeVersion=1.0-SNAPSHOT -DgroupId=org.me.test  -DartifactId=my-module`

**Windows (which needs each -D option surrounded by douple quotes)**

`mvn archetype:generate "-DarchetypeGroupId=org.ikasan.studio" "-DarchetypeArtifactId=studio-project" "-DarchetypeVersion=1.0-SNAPSHOT" "-DgroupId=org.me.test" "-DartifactId=my-module"`

(remember so swap org.me.test and my-module for the package and module name for **your project**)

## Known issues
### Does not build
To get  project to build, the flows must be valid i.e. they must have at least a consumer and a producer.
### Dependencies not satisfied
When you first create a project, you may find red highlights and basic Spring dependencies are not satisfied. Use the (standard) Maven update for the project, it will re-pull the dependencies (the root casue is a threading issue inside Intellij, this will be fixed eventually)
### Deleted components are not always removed
Please work around this for now, it wwill be fixed shortly.

## Development Guidelines
### Do not let any exceptions bubble up to Intellij
These get reported directly to the user with the recommendation to disable the plugin and report it to Idea.
Where possible, log it with a stack trace and try to recover or abort that particular operation.
### Do not use @NotNull
These bubble up to the IDE with the recommendation to disable the plugin and report it to Idea.
### Do not use anything greater than warn when using Intellij's logger
Anything greater than warn results in a stack trace reported directly to the user with the recommendation to disable the plugin and report it to Idea.
### Defensive coding is essential
You don't have to make many mistakes to get blacklisted.

## Template ToDo list
- [x] Create a new [IntelliJ Platform Plugin Template][template] project.
- [ ] Get familiar with the [template documentation][template].
- [ ] Adjust the [pluginGroup](./gradle.properties), [plugin ID](./src/main/resources/META-INF/plugin.xml) and [sources package](./src/main/kotlin).
- [ ] Adjust the plugin description in `README` (see [Tips][docs:plugin-description])
- [ ] Review the [Legal Agreements](https://plugins.jetbrains.com/docs/marketplace/legal-agreements.html?from=IJPluginTemplate).BASIC
- [ ] [Publish a plugin manually](https://plugins.jetbrains.com/docs/intellij/publishing-plugin.html?from=IJPluginTemplate) for the first time.
- [ ] Set the `PLUGIN_ID` in the above README badges.
- [ ] Set the [Plugin Signing](https://plugins.jetbrains.com/docs/intellij/plugin-signing.html?from=IJPluginTemplate) related [secrets](https://github.com/JetBrains/intellij-platform-plugin-template#environment-variables).
- [ ] Set the [Deployment Token](https://plugins.jetbrains.com/docs/marketplace/plugin-upload.html?from=IJPluginTemplate).
- [ ] Click the <kbd>Watch</kbd> button on the top of the [IntelliJ Platform Plugin Template][template] to be notified about releases containing new features and fixes.

<!-- Plugin description -->
This Fancy IntelliJ Platform Plugin is going to be your implementation of the brilliant ideas that you have.

This specific section is a source for the [plugin.xml](/src/main/resources/META-INF/plugin.xml) file which will be extracted by the [Gradle](/build.gradle.kts) during the build process.

To keep everything working, do not remove `<!-- ... -->` sections.
<!-- Plugin description end -->

## Installation

- Using the IDE built-in plugin system:

  <kbd>Settings/Preferences</kbd> > <kbd>Plugins</kbd> > <kbd>Marketplace</kbd> > <kbd>Search for "IkasanStudio"</kbd> >
  <kbd>Install</kbd>

- Manually:

  Download the [latest release](https://github.com/davidhilton68/IkasanStudio2/releases/latest) and install it manually using
  <kbd>Settings/Preferences</kbd> > <kbd>Plugins</kbd> > <kbd>⚙️</kbd> > <kbd>Install plugin from disk...</kbd>


---
Plugin based on the [IntelliJ Platform Plugin Template][template].