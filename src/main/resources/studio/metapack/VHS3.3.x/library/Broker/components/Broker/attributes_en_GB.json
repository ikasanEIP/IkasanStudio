{
  "name": "Broker",
  "flowBuilderMethod": "broker",
  "generatesUserImplementedClass": "true",
  "helpText": "<html><body><h3>Brokers</h3><p>Brokers enrich the contents of the existing message with additional data or structure in a number of different ways.</p><p>Request Response Brokers can make calls to other systems such as a database or HTTP(s) RESTful services. Aggregating Brokers consume all incoming messages until a condition is met ie aggregate every 10 messages. Re-Sequencing Brokers consume all incoming messages until a condition is met and then release them messages as a list of newly ordered events. This can provide a powerful function when combined with a Splitter as the next component</p></body></html>",
  "implementingClass": "org.ikasan.spec.component.endpoint.Broker",
  "webHelpURL": "https://github.com/ikasanEIP/ikasan/blob/3.1.x/ikasaneip/component/Readme.md",
  "properties": {
    "componentName": {
      "propertyName": "componentName",
      "helpText": "The name of the component as displayed on diagrams, space are encouraged, succinct is best. The name should be unique for the flow. The name will be used internally to reflect the bean created.",
      "mandatory": true
    },
    "configurable": {
      "propertyName": "configurable",
      "helpText": "This property reflects that a component has the necessary configuration setup so that it can be edited in the blue console. Its is more of a status and as such is not explicitly used.",
      "ignoreProperty": true
    },
    "requiresStub": {
      "propertyName": "requiresStub",
      "helpText": "Does this component require a stub to be generated by Studio, if not, it is assumed the user will provide the instance from its own factory class."
    },
    "userImplementedClassName": {
      "propertyName": "userImplementedClassName",
      "userImplementClassFtlTemplate": "brokerTemplate.ftl",
      "affectsUserImplementedClass": "true",
      "helpText": "The name of the class that contain the broker, the IDE will create a template for this class, the user  must provide the implementation.",
      "mandatory": true,
      "validation": "^[A-Z_$][a-zA-Z\\d_$£]*$",
      "validationMessage": "Provide a valid java classname for the broker e.g. starting with upper case, followed by number/characters etc."
    },
    "fromType": {
      "propertyName": "fromType",
      "affectsUserImplementedClass": "true",
      "defaultValue": "java.lang.String",
      "helpText": "The type of data we expect to come into the broker. This can be any Java class.",
      "mandatory": true,
      "validation": "^([a-zA-Z_$][a-zA-Z\\d_$]*\\.)*[A-Z_$][a-zA-Z\\d_$£]*",
      "validationMessage": "Provide a fully qualified Java class name to be used as the type for the input to the broker."
    },
    "toType": {
      "propertyName": "toType",
      "affectsUserImplementedClass": "true",
      "defaultValue": "java.lang.String",
      "helpText": "The type of data we expect to be the output of the the broker. This can be any Java class.",
      "mandatory": true,
      "validation": "^([a-zA-Z_$][a-zA-Z\\d_$]*\\.)*[A-Z_$][a-zA-Z\\d_$£]*",
      "validationMessage": "Provide a fully qualified Java class name to be used as the type for the input to the broker."
    }
  }
}

